// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

namespace Microsoft.Quantum.QsCompiler.CircuitTransformer

open System
open System.Collections.Generic
open System.Collections.Immutable
open System.Linq

open Microsoft.CodeAnalysis
open Microsoft.CodeAnalysis.CSharp.Syntax
open Microsoft.CodeAnalysis.Formatting

open Microsoft.Quantum.RoslynWrapper
open Microsoft.Quantum.QsCompiler
open Microsoft.Quantum.QsCompiler.DataTypes
open Microsoft.Quantum.QsCompiler.ReservedKeywords
open Microsoft.Quantum.QsCompiler.SyntaxTokens
open Microsoft.Quantum.QsCompiler.SyntaxTree
open Microsoft.Quantum.QsCompiler.SyntaxProcessing.Expressions
open Microsoft.Quantum.QsCompiler.SyntaxExtensions
open Microsoft.Quantum.QsCompiler.Transformations.BasicTransformations

module public CircuitTransformer =
    open Microsoft.Quantum.QsCompiler.Transformations
    open System.Globalization

    type CodegenContext = {
        allQsElements   : IEnumerable<QsNamespace>
        allUdts         : ImmutableDictionary<QsQualifiedName,QsCustomType>
        allCallables    : ImmutableDictionary<QsQualifiedName,QsCallable>
        byName          : ImmutableDictionary<NonNullable<string>,(NonNullable<string>*QsCallable) list>
        current         : QsQualifiedName option
        signature       : ResolvedSignature option
        fileName        : string option
    }

    type CodegenContext with
        member this.setCallable (op: QsCallable) = { this with current = (Some op.FullName); signature = (Some op.Signature) }
        member this.setUdt (udt: QsCustomType) = { this with current = (Some udt.FullName) }

    let createContext fileName syntaxTree =
        let udts = GlobalTypeResolutions syntaxTree
        let callables = GlobalCallableResolutions syntaxTree
        let callablesByName =
            let result = new Dictionary<NonNullable<string>,(NonNullable<string>*QsCallable) list>()
            syntaxTree |> Seq.collect (fun ns -> ns.Elements |> Seq.choose (function
            | QsCallable c -> Some (ns, c)
            | _ -> None))
            |> Seq.iter (fun (ns:QsNamespace,c:QsCallable) ->
                if result.ContainsKey c.FullName.Name then result.[c.FullName.Name] <- (ns.Name, c) :: (result.[c.FullName.Name])
                else result.[c.FullName.Name] <- [ns.Name, c])
            result.ToImmutableDictionary()
        { allQsElements = syntaxTree; byName = callablesByName; allUdts = udts; allCallables = callables; current = None; fileName = fileName; signature = None }


    type private ConditionalChangerStatement(stm, ctx : CodegenContext) =
        inherit StatementKindTransformation<ConditionalChangerScope>(stm)

        override this.onConditionalStatement (node:QsConditionalStatement) =
            printfn "found an if!"
            // printfn "%s" <| Option.get ctx.fileName
            // if in the form of if (M(x) == One)
            let shouldTransform =
                match node.ConditionalBlocks |> Seq.toList with
                | [ (typedExpr, block) ] ->
                    match block.Body.Statements |> Seq.toList with
                    | [ (stm) ] ->
                        match stm.Statement with
                        | QsExpressionStatement typedExpr ->
                            match typedExpr.Expression with
                            | CallLikeExpression (fn, args) -> true
                            | _ -> false
                        | _ -> false
                    | _ -> false
                    &&
                    match typedExpr.Expression with
                    | EQ (lhs, rhs) -> rhs.Expression = ResultLiteral One &&
                                            match lhs.Expression with
                                            | CallLikeExpression (fn, args) ->
                                                let isMeasure =
                                                    match fn.Expression with
                                                    | Identifier (symbol, _) -> symbol = GlobalCallable {Namespace = "Microsoft.Quantum.Intrinsic" |> NonNullable<string>.New; Name = "M" |> NonNullable<string>.New;}
                                                    | _ -> false
                                                let isIdentifier =
                                                    match args.Expression with
                                                    | Identifier _ -> true
                                                    | _ -> false
                                                isMeasure && isIdentifier
                                            | _ -> false
                    | _ -> false
                | _ -> false


            let AutoGeneratedExpression kind exTypeKind qDep =
                let noInferredInfo = InferredExpressionInformation.New (false, quantumDep = qDep)
                TypedExpression.New (kind, ImmutableDictionary.Empty, exTypeKind |> ResolvedType.New, noInferredInfo, QsRangeInfo.Null)

            let functionIdentifier = {Namespace = "Microsoft.Quantum.ClassicalControl" |> NonNullable<string>.New;
                    Name = "ApplyIfOne" |> NonNullable<string>.New}

            let functionName typeParam =
                // What's the first parameter to QsTypeKind.Function? It's called in type in source code but what that?
                let exTypeKind = QsTypeKind.Function (QsTypeKind.Result |> ResolvedType.New, QsTypeKind.UnitType |> ResolvedType.New)
                AutoGeneratedExpression (QsExpressionKind.Identifier (Identifier.GlobalCallable functionIdentifier, typeParam)) exTypeKind false

            let inferredInfo = InferredExpressionInformation.New (false, // IsMutable
                                                                   true) // HasLocalQuantumDependency


            if shouldTransform then
                printfn "transforming on %A" node
                let controlQubitExpr =
                    match node.ConditionalBlocks |> Seq.toList with
                    | [ (typedExpr, _) ] ->
                        match typedExpr.Expression with
                        | EQ (lhs, _) -> Some lhs
                        | _ -> None
                    | _ -> None
                let (operationExpr, operationArgExpr) =
                    match node.ConditionalBlocks |> Seq.toList with
                    | [ (_, block) ] ->
                        match block.Body.Statements |> Seq.toList with
                        | [ (stm) ] ->
                            match stm.Statement with
                            | QsExpressionStatement typedExpr ->
                                match typedExpr.Expression with
                                | CallLikeExpression (fn, args) -> (Some fn, Some args)
                                | _ -> (None, None)
                            | _ -> (None, None)
                        | _ -> (None, None)
                    | _ -> (None, None)


                // Transform to this, where onResultOneOp and oneArg is the innerArgsTuple
                // ApplyIfOne<'T>(  measurementResult : Result, (onResultOneOp : ('T => Unit), oneArg : 'T) ) : Unit
                //
                let innerArgsTuple = QsExpressionKind.ValueTuple ([
                    Option.get operationExpr;
                    Option.get operationArgExpr
                    ].ToImmutableArray())
                let innerArgsTupleType =
                    [
                        (Option.get operationExpr).ResolvedType;
                        (Option.get operationArgExpr).ResolvedType
                    ].ToImmutableArray() |> TupleType
                let innerArgsTupleTypedExpr = AutoGeneratedExpression innerArgsTuple innerArgsTupleType false

                let argsExpr = QsExpressionKind.ValueTuple ([
                    Option.get controlQubitExpr;
                    innerArgsTupleTypedExpr
                    ].ToImmutableArray())
                let argsType =
                    [
                        (Option.get controlQubitExpr).ResolvedType;
                        innerArgsTupleTypedExpr.ResolvedType
                    ].ToImmutableArray() |> TupleType

                let argsTypedExpr = AutoGeneratedExpression argsExpr argsType false
                let exprKind = CallLikeExpression (functionName (QsNullable.Value ([((Option.get operationArgExpr).ResolvedType)].ToImmutableArray())), argsTypedExpr)

/// Creates a typed expression that corresponds to a call to the Length function.
/// The Length function needs to be part of the QsCore library, and its type parameter name needs to match the one here.
/// Throws an ArgumentException if the given expression is not of type array or of invalid type.
//let private Length (ex : TypedExpression) =
//    let functionName, tpName = "Length", "T"
//    let callableName = {Namespace = QsCoreNamespace; Name = functionName |> NonNullable<string>.New}
//    let kind = Identifier.GlobalCallable callableName
//    let typeParameter = QsTypeParameter.New (callableName.Namespace, callableName.Name, tpName |> NonNullable<string>.New, Null)
//    let genArrayType = QsTypeKind.ArrayType (QsTypeKind.TypeParameter typeParameter |> ResolvedType.New) |> ResolvedType.New
//    let exTypeKind = QsTypeKind.Function (genArrayType, QsTypeKind.Int |> ResolvedType.New)
//    let length = AutoGeneratedExpression (QsExpressionKind.Identifier (kind, Null)) exTypeKind false
//    let callToLength tpRes =
//        let resolutions = (seq { yield (typeParameter, tpRes) }).ToImmutableDictionary(fst, snd)
//        {CallNonGeneric (length, ex) with TypeParameterResolutions = resolutions}
//    match ex.ResolvedType.Resolution with
//    | ArrayType b -> callToLength b
//    | InvalidType -> callToLength ex.ResolvedType
//    | _ -> ArgumentException "the given expression is not of array type" |> raise


                let typeparameter = QsTypeParameter.New (functionIdentifier.Namespace, functionIdentifier.Name, "T" |> NonNullable<string>.New, Null)
                let tpResolutions = (new Dictionary<QsTypeParameter, ResolvedType>(dict [(typeparameter, (Option.get operationArgExpr).ResolvedType)])).ToImmutableDictionary();
                QsExpressionStatement <| TypedExpression.New (exprKind, tpResolutions, QsTypeKind.UnitType |> ResolvedType.New, inferredInfo, QsRangeInfo.Null)  //exTypeKind here is return type
            else
                base.onConditionalStatement node


//call measurement - need an extra intermediary node? give it a "resolved type" "Result"?
//build library file and use library file
//test edge cases
//write tests
//test that compiled code actually works??



    and private ConditionalChangerScope(ctx) =
        inherit ScopeTransformation<ConditionalChangerStatement, NoExpressionTransformations>
                (Func<_,_>(fun s -> new ConditionalChangerStatement(s :?> ConditionalChangerScope, ctx)),
                 new NoExpressionTransformations())

    type private CondtionalChangerSyntaxTree(ctx) =
        inherit SyntaxTreeTransformation<ConditionalChangerScope>(new ConditionalChangerScope(ctx))

    let public basicWalk (allQsElements : seq<QsNamespace>) =
        let globalContext = createContext (Some "imafilename") allQsElements
        allQsElements |> Seq.map (CondtionalChangerSyntaxTree(globalContext)).Transform |> Seq.toList // |> ignore
